Release "orbilnot" does not exist. Installing it now.
NAME: orbilnot
LAST DEPLOYED: Mon Oct 28 23:42:39 2024
NAMESPACE: default
STATUS: pending-install
REVISION: 1
TEST SUITE: None
HOOKS:
MANIFEST:
---
# Source: orbilnot/charts/kafka/charts/zookeeper/templates/networkpolicy.yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: orbilnot-zookeeper
  namespace: default
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: zookeeper
    app.kubernetes.io/version: 3.9.2
    helm.sh/chart: zookeeper-13.4.13
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/instance: orbilnot
      app.kubernetes.io/name: zookeeper
  policyTypes:
    - Ingress
    - Egress
  egress:
    - {}
  ingress:
    # Allow inbound connections to ZooKeeper
    - ports:
        - port: 2181
    # Allow internal communications between nodes
    - ports:
        - port: 2888
        - port: 3888
      from:
        - podSelector:
            matchLabels:
              app.kubernetes.io/instance: orbilnot
              app.kubernetes.io/name: zookeeper
---
# Source: orbilnot/charts/kafka/templates/networkpolicy.yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: orbilnot-kafka
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 3.8.0
    helm.sh/chart: kafka-30.1.6
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/instance: orbilnot
      app.kubernetes.io/name: kafka
  policyTypes:
    - Ingress
    - Egress
  egress:
    - {}
  ingress:
    # Allow client connections
    - ports:
        - port: 9092
        - port: 9094
        - port: 9093
---
# Source: orbilnot/charts/postgresql/templates/primary/networkpolicy.yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: orbilnot-postgresql
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 16.4.0
    helm.sh/chart: postgresql-15.5.24
    app.kubernetes.io/component: primary
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/instance: orbilnot
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/component: primary
  policyTypes:
    - Ingress
    - Egress
  egress:
    - {}
  ingress:
    - ports:
        - port: 5432
---
# Source: orbilnot/charts/kafka/charts/zookeeper/templates/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: orbilnot-zookeeper
  namespace: default
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: zookeeper
    app.kubernetes.io/version: 3.9.2
    helm.sh/chart: zookeeper-13.4.13
    app.kubernetes.io/component: zookeeper
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: orbilnot
      app.kubernetes.io/name: zookeeper
      app.kubernetes.io/component: zookeeper
---
# Source: orbilnot/charts/kafka/templates/broker/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: orbilnot-kafka-broker
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 3.8.0
    helm.sh/chart: kafka-30.1.6
    app.kubernetes.io/component: broker
    app.kubernetes.io/part-of: kafka
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: orbilnot
      app.kubernetes.io/name: kafka
      app.kubernetes.io/component: broker
      app.kubernetes.io/part-of: kafka
---
# Source: orbilnot/charts/kafka/templates/controller-eligible/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: orbilnot-kafka-controller
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 3.8.0
    helm.sh/chart: kafka-30.1.6
    app.kubernetes.io/component: controller-eligible
    app.kubernetes.io/part-of: kafka
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: orbilnot
      app.kubernetes.io/name: kafka
      app.kubernetes.io/component: controller-eligible
      app.kubernetes.io/part-of: kafka
---
# Source: orbilnot/charts/postgresql/templates/primary/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: orbilnot-postgresql
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 16.4.0
    helm.sh/chart: postgresql-15.5.24
    app.kubernetes.io/component: primary
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: orbilnot
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/component: primary
---
# Source: orbilnot/charts/kafka/charts/zookeeper/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: orbilnot-zookeeper
  namespace: default
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: zookeeper
    app.kubernetes.io/version: 3.9.2
    helm.sh/chart: zookeeper-13.4.13
    app.kubernetes.io/component: zookeeper
    role: zookeeper
automountServiceAccountToken: false
---
# Source: orbilnot/charts/kafka/templates/provisioning/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: orbilnot-kafka-provisioning
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 3.8.0
    helm.sh/chart: kafka-30.1.6
automountServiceAccountToken: false
---
# Source: orbilnot/charts/kafka/templates/rbac/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: orbilnot-kafka
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 3.8.0
    helm.sh/chart: kafka-30.1.6
    app.kubernetes.io/component: kafka
automountServiceAccountToken: false
---
# Source: orbilnot/charts/postgresql/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: orbilnot-postgresql
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 16.4.0
    helm.sh/chart: postgresql-15.5.24
automountServiceAccountToken: false
---
# Source: orbilnot/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: orbilnot
  labels:
    helm.sh/chart: orbilnot-0.1.0
    app.kubernetes.io/name: orbilnot
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
automountServiceAccountToken: true
---
# Source: orbilnot/charts/kafka/templates/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: orbilnot-kafka-user-passwords
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 3.8.0
    helm.sh/chart: kafka-30.1.6
type: Opaque
data:
  client-passwords: "enpTNnlIaEs2OA=="
  system-user-password: "enpTNnlIaEs2OA=="
  inter-broker-password: "ak9Cb0hNQXNVeA=="
  controller-password: "UmYyTjNVNlpFUA=="
---
# Source: orbilnot/charts/kafka/templates/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: orbilnot-kafka-kraft-cluster-id
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 3.8.0
    helm.sh/chart: kafka-30.1.6
type: Opaque
data:
  kraft-cluster-id: "NzNQNnM1YkhJNGF1TmF5aXBWY1JPZg=="
---
# Source: orbilnot/charts/postgresql/templates/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: orbilnot-postgresql
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 16.4.0
    helm.sh/chart: postgresql-15.5.24
type: Opaque
data:
  postgres-password: "cXdlcnR5"
  # We don't auto-generate LDAP password when it's not provided as we do for other passwords
---
# Source: orbilnot/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: db-creds-secret
type: Opaque
data:
  username: cG9zdGdyZXM=
  password: cXdlcnR5
---
# Source: orbilnot/charts/kafka/charts/zookeeper/templates/scripts-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: orbilnot-zookeeper-scripts
  namespace: default
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: zookeeper
    app.kubernetes.io/version: 3.9.2
    helm.sh/chart: zookeeper-13.4.13
    app.kubernetes.io/component: zookeeper
data:
  init-certs.sh: |-
    #!/bin/bash
  setup.sh: |-
    #!/bin/bash

    # Execute entrypoint as usual after obtaining ZOO_SERVER_ID
    # check ZOO_SERVER_ID in persistent volume via myid
    # if not present, set based on POD hostname
    if [[ -f "/bitnami/zookeeper/data/myid" ]]; then
        export ZOO_SERVER_ID="$(cat /bitnami/zookeeper/data/myid)"
    else
        HOSTNAME="$(hostname -s)"
        if [[ $HOSTNAME =~ (.*)-([0-9]+)$ ]]; then
            ORD=${BASH_REMATCH[2]}
            export ZOO_SERVER_ID="$((ORD + 1 ))"
        else
            echo "Failed to get index from hostname $HOSTNAME"
            exit 1
        fi
    fi
    exec /entrypoint.sh /run.sh
---
# Source: orbilnot/charts/kafka/templates/controller-eligible/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: orbilnot-kafka-controller-configuration
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 3.8.0
    helm.sh/chart: kafka-30.1.6
    app.kubernetes.io/component: controller-eligible
    app.kubernetes.io/part-of: kafka
data:
  server.properties: |-
    # Listeners configuration
    listeners=CLIENT://:9092,INTERNAL://:9094,CONTROLLER://:9093
    advertised.listeners=CLIENT://advertised-address-placeholder:9092,INTERNAL://advertised-address-placeholder:9094
    listener.security.protocol.map=CLIENT:SASL_PLAINTEXT,INTERNAL:SASL_PLAINTEXT,CONTROLLER:SASL_PLAINTEXT
    # KRaft process roles
    process.roles=controller,broker
    #node.id=
    controller.listener.names=CONTROLLER
    controller.quorum.voters=0@orbilnot-kafka-controller-0.orbilnot-kafka-controller-headless.default.svc.cluster.local:9093,1@orbilnot-kafka-controller-1.orbilnot-kafka-controller-headless.default.svc.cluster.local:9093,2@orbilnot-kafka-controller-2.orbilnot-kafka-controller-headless.default.svc.cluster.local:9093
    # Kraft Controller listener SASL settings
    sasl.mechanism.controller.protocol=PLAIN
    listener.name.controller.sasl.enabled.mechanisms=PLAIN
    listener.name.controller.plain.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="controller_user" password="controller-password-placeholder" user_controller_user="controller-password-placeholder";
    # Kafka data logs directory
    log.dir=/bitnami/kafka/data
    # Kafka application logs directory
    logs.dir=/opt/bitnami/kafka/logs

    # Common Kafka Configuration
    
    sasl.enabled.mechanisms=PLAIN,SCRAM-SHA-256,SCRAM-SHA-512
    # Interbroker configuration
    inter.broker.listener.name=INTERNAL
    sasl.mechanism.inter.broker.protocol=PLAIN
    # Listeners SASL JAAS configuration
    listener.name.client.plain.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required user_user1="password-placeholder-0";
    listener.name.client.scram-sha-256.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required;
    listener.name.client.scram-sha-512.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required;
    listener.name.internal.plain.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="inter_broker_user" password="interbroker-password-placeholder" user_inter_broker_user="interbroker-password-placeholder" user_user1="password-placeholder-0";
    listener.name.internal.scram-sha-256.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username="inter_broker_user" password="interbroker-password-placeholder";
    listener.name.internal.scram-sha-512.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username="inter_broker_user" password="interbroker-password-placeholder";
    # End of SASL JAAS configuration

    # Custom Kafka Configuration
---
# Source: orbilnot/charts/kafka/templates/scripts-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: orbilnot-kafka-scripts
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 3.8.0
    helm.sh/chart: kafka-30.1.6
data:
  kafka-init.sh: |-
    #!/bin/bash

    set -o errexit
    set -o nounset
    set -o pipefail

    error(){
      local message="${1:?missing message}"
      echo "ERROR: ${message}"
      exit 1
    }

    retry_while() {
        local -r cmd="${1:?cmd is missing}"
        local -r retries="${2:-12}"
        local -r sleep_time="${3:-5}"
        local return_value=1

        read -r -a command <<< "$cmd"
        for ((i = 1 ; i <= retries ; i+=1 )); do
            "${command[@]}" && return_value=0 && break
            sleep "$sleep_time"
        done
        return $return_value
    }

    replace_in_file() {
        local filename="${1:?filename is required}"
        local match_regex="${2:?match regex is required}"
        local substitute_regex="${3:?substitute regex is required}"
        local posix_regex=${4:-true}

        local result

        # We should avoid using 'sed in-place' substitutions
        # 1) They are not compatible with files mounted from ConfigMap(s)
        # 2) We found incompatibility issues with Debian10 and "in-place" substitutions
        local -r del=$'\001' # Use a non-printable character as a 'sed' delimiter to avoid issues
        if [[ $posix_regex = true ]]; then
            result="$(sed -E "s${del}${match_regex}${del}${substitute_regex}${del}g" "$filename")"
        else
            result="$(sed "s${del}${match_regex}${del}${substitute_regex}${del}g" "$filename")"
        fi
        echo "$result" > "$filename"
    }

    kafka_conf_set() {
        local file="${1:?missing file}"
        local key="${2:?missing key}"
        local value="${3:?missing value}"

        # Check if the value was set before
        if grep -q "^[#\\s]*$key\s*=.*" "$file"; then
            # Update the existing key
            replace_in_file "$file" "^[#\\s]*${key}\s*=.*" "${key}=${value}" false
        else
            # Add a new key
            printf '\n%s=%s' "$key" "$value" >>"$file"
        fi
    }

    replace_placeholder() {
      local placeholder="${1:?missing placeholder value}"
      local password="${2:?missing password value}"
      local -r del=$'\001' # Use a non-printable character as a 'sed' delimiter to avoid issues with delimiter symbols in sed string
      sed -i "s${del}$placeholder${del}$password${del}g" "$KAFKA_CONFIG_FILE"
    }

    append_file_to_kafka_conf() {
        local file="${1:?missing source file}"
        local conf="${2:?missing kafka conf file}"

        cat "$1" >> "$2"
    }

    configure_external_access() {
      # Configure external hostname
      if [[ -f "/shared/external-host.txt" ]]; then
        host=$(cat "/shared/external-host.txt")
      elif [[ -n "${EXTERNAL_ACCESS_HOST:-}" ]]; then
        host="$EXTERNAL_ACCESS_HOST"
      elif [[ -n "${EXTERNAL_ACCESS_HOSTS_LIST:-}" ]]; then
        read -r -a hosts <<<"$(tr ',' ' ' <<<"${EXTERNAL_ACCESS_HOSTS_LIST}")"
        host="${hosts[$POD_ID]}"
      elif [[ "$EXTERNAL_ACCESS_HOST_USE_PUBLIC_IP" =~ ^(yes|true)$ ]]; then
        host=$(curl -s https://ipinfo.io/ip)
      else
        error "External access hostname not provided"
      fi

      # Configure external port
      if [[ -f "/shared/external-port.txt" ]]; then
        port=$(cat "/shared/external-port.txt")
      elif [[ -n "${EXTERNAL_ACCESS_PORT:-}" ]]; then
        if [[ "${EXTERNAL_ACCESS_PORT_AUTOINCREMENT:-}" =~ ^(yes|true)$ ]]; then
          port="$((EXTERNAL_ACCESS_PORT + POD_ID))"
        else
          port="$EXTERNAL_ACCESS_PORT"
        fi
      elif [[ -n "${EXTERNAL_ACCESS_PORTS_LIST:-}" ]]; then
        read -r -a ports <<<"$(tr ',' ' ' <<<"${EXTERNAL_ACCESS_PORTS_LIST}")"
        port="${ports[$POD_ID]}"
      else
        error "External access port not provided"
      fi
      # Configure Kafka advertised listeners
      sed -i -E "s|^(advertised\.listeners=\S+)$|\1,EXTERNAL://${host}:${port}|" "$KAFKA_CONFIG_FILE"
    }
    configure_kafka_sasl() {

      # Replace placeholders with passwords
      replace_placeholder "interbroker-password-placeholder" "$KAFKA_INTER_BROKER_PASSWORD"
      replace_placeholder "controller-password-placeholder" "$KAFKA_CONTROLLER_PASSWORD"
      read -r -a passwords <<<"$(tr ',;' ' ' <<<"${KAFKA_CLIENT_PASSWORDS:-}")"
      for ((i = 0; i < ${#passwords[@]}; i++)); do
          replace_placeholder "password-placeholder-${i}\"" "${passwords[i]}\""
      done
    }

    export KAFKA_CONFIG_FILE=/config/server.properties
    cp /configmaps/server.properties $KAFKA_CONFIG_FILE

    # Get pod ID and role, last and second last fields in the pod name respectively
    POD_ID=$(echo "$MY_POD_NAME" | rev | cut -d'-' -f 1 | rev)
    POD_ROLE=$(echo "$MY_POD_NAME" | rev | cut -d'-' -f 2 | rev)

    # Configure node.id and/or broker.id
    if [[ -f "/bitnami/kafka/data/meta.properties" ]]; then
        if grep -q "broker.id" /bitnami/kafka/data/meta.properties; then
          ID="$(grep "broker.id" /bitnami/kafka/data/meta.properties | awk -F '=' '{print $2}')"
          kafka_conf_set "$KAFKA_CONFIG_FILE" "node.id" "$ID"
        else
          ID="$(grep "node.id" /bitnami/kafka/data/meta.properties | awk -F '=' '{print $2}')"
          kafka_conf_set "$KAFKA_CONFIG_FILE" "node.id" "$ID"
        fi
    else
        ID=$((POD_ID + KAFKA_MIN_ID))
        kafka_conf_set "$KAFKA_CONFIG_FILE" "node.id" "$ID"
    fi
    replace_placeholder "advertised-address-placeholder" "${MY_POD_NAME}.orbilnot-kafka-${POD_ROLE}-headless.default.svc.cluster.local"
    if [[ "${EXTERNAL_ACCESS_ENABLED:-false}" =~ ^(yes|true)$ ]]; then
      configure_external_access
    fi
    configure_kafka_sasl
    if [ -f /secret-config/server-secret.properties ]; then
      append_file_to_kafka_conf /secret-config/server-secret.properties $KAFKA_CONFIG_FILE
    fi
---
# Source: orbilnot/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-configmap
data:
  POSTGRES_SVC: "orbilnot-postgresql"
  POSTGRES_PORT: "5432"
  POSTGRES_DB: "postgres"
---
# Source: orbilnot/templates/role.yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: orbilnot
rules:
  - apiGroups:
      - ""
      - "apps"
      - "batch"
    resources:
      - endpoints
      - deployments
      - pods
      - jobs
    verbs:
      - get
      - list
      - watch
      - create
      - delete
---
# Source: orbilnot/templates/rolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: orbilnot
  namespace: default
subjects:
  - kind: ServiceAccount
    name: orbilnot
    namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: orbilnot
---
# Source: orbilnot/charts/kafka/charts/zookeeper/templates/svc-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: orbilnot-zookeeper-headless
  namespace: default
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: zookeeper
    app.kubernetes.io/version: 3.9.2
    helm.sh/chart: zookeeper-13.4.13
    app.kubernetes.io/component: zookeeper
spec:
  type: ClusterIP
  clusterIP: None
  publishNotReadyAddresses: true
  ports:
    - name: tcp-client
      port: 2181
      targetPort: client
    - name: tcp-follower
      port: 2888
      targetPort: follower
    - name: tcp-election
      port: 3888
      targetPort: election
  selector:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/name: zookeeper
    app.kubernetes.io/component: zookeeper
---
# Source: orbilnot/charts/kafka/charts/zookeeper/templates/svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: orbilnot-zookeeper
  namespace: default
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: zookeeper
    app.kubernetes.io/version: 3.9.2
    helm.sh/chart: zookeeper-13.4.13
    app.kubernetes.io/component: zookeeper
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
    - name: tcp-client
      port: 2181
      targetPort: client
      nodePort: null
  selector:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/name: zookeeper
    app.kubernetes.io/component: zookeeper
---
# Source: orbilnot/charts/kafka/templates/controller-eligible/svc-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: orbilnot-kafka-controller-headless
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 3.8.0
    helm.sh/chart: kafka-30.1.6
    app.kubernetes.io/component: controller-eligible
    app.kubernetes.io/part-of: kafka
spec:
  type: ClusterIP
  clusterIP: None
  publishNotReadyAddresses: true
  ports:
    - name: tcp-interbroker
      port: 9094
      protocol: TCP
      targetPort: interbroker
    - name: tcp-client
      port: 9092
      protocol: TCP
      targetPort: client
    - name: tcp-controller
      protocol: TCP
      port: 9093
      targetPort: controller
  selector:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/name: kafka
    app.kubernetes.io/component: controller-eligible
    app.kubernetes.io/part-of: kafka
---
# Source: orbilnot/charts/kafka/templates/svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: orbilnot-kafka
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 3.8.0
    helm.sh/chart: kafka-30.1.6
    app.kubernetes.io/component: kafka
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
    - name: tcp-client
      port: 9092
      protocol: TCP
      targetPort: client
      nodePort: null
  selector:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/name: kafka
    app.kubernetes.io/part-of: kafka
---
# Source: orbilnot/charts/postgresql/templates/primary/svc-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: orbilnot-postgresql-hl
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 16.4.0
    helm.sh/chart: postgresql-15.5.24
    app.kubernetes.io/component: primary
  annotations:
spec:
  type: ClusterIP
  clusterIP: None
  # We want all pods in the StatefulSet to have their addresses published for
  # the sake of the other Postgresql pods even before they're ready, since they
  # have to be able to talk to each other in order to become ready.
  publishNotReadyAddresses: true
  ports:
    - name: tcp-postgresql
      port: 5432
      targetPort: tcp-postgresql
  selector:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/component: primary
---
# Source: orbilnot/charts/postgresql/templates/primary/svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: orbilnot-postgresql
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 16.4.0
    helm.sh/chart: postgresql-15.5.24
    app.kubernetes.io/component: primary
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
    - name: tcp-postgresql
      port: 5432
      targetPort: tcp-postgresql
      nodePort: null
  selector:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/component: primary
---
# Source: orbilnot/templates/biling-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: billing-orbilnot
  labels:
    helm.sh/chart: orbilnot-0.1.0
    app.kubernetes.io/name: orbilnot
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
    tier: billing
spec:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: 8000
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/name: orbilnot
    app.kubernetes.io/instance: orbilnot
    tier: billing
---
# Source: orbilnot/templates/gateway-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: gateway-orbilnot
  labels:
    helm.sh/chart: orbilnot-0.1.0
    app.kubernetes.io/name: orbilnot
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
    tier: gateway
spec:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: 8080
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/name: orbilnot
    app.kubernetes.io/instance: orbilnot
    tier: gateway
---
# Source: orbilnot/templates/notification-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: notification-orbilnot
  labels:
    helm.sh/chart: orbilnot-0.1.0
    app.kubernetes.io/name: orbilnot
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
    tier: notification
spec:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: 8000
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/name: orbilnot
    app.kubernetes.io/instance: orbilnot
    tier: notification
---
# Source: orbilnot/templates/order-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: order-orbilnot
  labels:
    helm.sh/chart: orbilnot-0.1.0
    app.kubernetes.io/name: orbilnot
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
    tier: order
spec:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: 8000
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/name: orbilnot
    app.kubernetes.io/instance: orbilnot
    tier: order
---
# Source: orbilnot/templates/billing-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name:
    billing-orbilnot
  labels:
    helm.sh/chart: orbilnot-0.1.0
    app.kubernetes.io/name: orbilnot
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
    tier: billing
spec:
  replicas: 2
  selector:
    matchLabels:
      helm.sh/chart: orbilnot-0.1.0
      app.kubernetes.io/name: orbilnot
      app.kubernetes.io/instance: orbilnot
      app.kubernetes.io/version: "1.16.0"
      app.kubernetes.io/managed-by: Helm
      tier: billing
  template:
    metadata:
      labels:
        helm.sh/chart: orbilnot-0.1.0
        app.kubernetes.io/name: orbilnot
        app.kubernetes.io/instance: orbilnot
        app.kubernetes.io/version: "1.16.0"
        app.kubernetes.io/managed-by: Helm
        tier: billing
    spec:
      serviceAccountName:
        orbilnot
      initContainers:
        - name: "orbilnot-init"
          image: "groundnuty/k8s-wait-for:1.3"
          imagePullPolicy: IfNotPresent
          args:
            - "job"
            - "orbilnot-migration-job"
      containers:
        - name: orbilnot-billing
          image: "glebegunov/orbilnot-billing:0.0.1"
          imagePullPolicy: IfNotPresent
          ports:
            - name: http
              containerPort: 8000
              protocol: TCP
          envFrom:
            - configMapRef:
                name: postgres-configmap
          env:
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: db-creds-secret
                  key: username
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: db-creds-secret
                  key: password
          livenessProbe:
            httpGet:
              path: /billing/actuator/health
              port: 8000
            initialDelaySeconds: 60
---
# Source: orbilnot/templates/gateway-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name:
    gateway-orbilnot
  labels:
    helm.sh/chart: orbilnot-0.1.0
    app.kubernetes.io/name: orbilnot
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
    tier: gateway
spec:
  replicas: 2
  selector:
    matchLabels:
      helm.sh/chart: orbilnot-0.1.0
      app.kubernetes.io/name: orbilnot
      app.kubernetes.io/instance: orbilnot
      app.kubernetes.io/version: "1.16.0"
      app.kubernetes.io/managed-by: Helm
      tier: gateway
  template:
    metadata:
      labels:
        helm.sh/chart: orbilnot-0.1.0
        app.kubernetes.io/name: orbilnot
        app.kubernetes.io/instance: orbilnot
        app.kubernetes.io/version: "1.16.0"
        app.kubernetes.io/managed-by: Helm
        tier: gateway
    spec:
      serviceAccountName:
        orbilnot
      containers:
        - name: orbilnot-gateway
          image: "glebegunov/orbilnot-gateway:0.0.1"
          imagePullPolicy: IfNotPresent
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
---
# Source: orbilnot/templates/notification-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name:
    billing-orbilnot
  labels:
    helm.sh/chart: orbilnot-0.1.0
    app.kubernetes.io/name: orbilnot
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
    tier: billing
spec:
  replicas: 2
  selector:
    matchLabels:
      helm.sh/chart: orbilnot-0.1.0
      app.kubernetes.io/name: orbilnot
      app.kubernetes.io/instance: orbilnot
      app.kubernetes.io/version: "1.16.0"
      app.kubernetes.io/managed-by: Helm
      tier: notification
  template:
    metadata:
      labels:
        helm.sh/chart: orbilnot-0.1.0
        app.kubernetes.io/name: orbilnot
        app.kubernetes.io/instance: orbilnot
        app.kubernetes.io/version: "1.16.0"
        app.kubernetes.io/managed-by: Helm
        tier: notification
    spec:
      serviceAccountName:
        orbilnot
      initContainers:
        - name: "orbilnot-init"
          image: "groundnuty/k8s-wait-for:1.3"
          imagePullPolicy: IfNotPresent
          args:
            - "job"
            - "orbilnot-migration-job"
      containers:
        - name: orbilnot-notification
          image: "glebegunov/orbilnot-notification:0.0.1"
          imagePullPolicy: IfNotPresent
          ports:
            - name: http
              containerPort: 8000
              protocol: TCP
          envFrom:
            - configMapRef:
                name: postgres-configmap
          env:
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: db-creds-secret
                  key: username
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: db-creds-secret
                  key: password
          livenessProbe:
            httpGet:
              path: /billing/actuator/health
              port: 8000
            initialDelaySeconds: 60
---
# Source: orbilnot/templates/order-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name:
    order-orbilnot
  labels:
    helm.sh/chart: orbilnot-0.1.0
    app.kubernetes.io/name: orbilnot
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
    tier: order
spec:
  replicas: 2
  selector:
    matchLabels:
      helm.sh/chart: orbilnot-0.1.0
      app.kubernetes.io/name: orbilnot
      app.kubernetes.io/instance: orbilnot
      app.kubernetes.io/version: "1.16.0"
      app.kubernetes.io/managed-by: Helm
      tier: order
  template:
    metadata:
      labels:
        helm.sh/chart: orbilnot-0.1.0
        app.kubernetes.io/name: orbilnot
        app.kubernetes.io/instance: orbilnot
        app.kubernetes.io/version: "1.16.0"
        app.kubernetes.io/managed-by: Helm
        tier: order
    spec:
      serviceAccountName:
        orbilnot
      initContainers:
        - name: "orbilnot-init"
          image: "groundnuty/k8s-wait-for:1.3"
          imagePullPolicy: IfNotPresent
          args:
            - "job"
            - "orbilnot-migration-job"
      containers:
        - name: orbilnot-order
          image: "glebegunov/orbilnot-order:0.0.1"
          imagePullPolicy: IfNotPresent
          ports:
            - name: http
              containerPort: 8000
              protocol: TCP
          envFrom:
            - configMapRef:
                name: postgres-configmap
          env:
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: db-creds-secret
                  key: username
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: db-creds-secret
                  key: password
          livenessProbe:
            httpGet:
              path: /orders/actuator/health
              port: 8000
            initialDelaySeconds: 60
---
# Source: orbilnot/charts/kafka/charts/zookeeper/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: orbilnot-zookeeper
  namespace: default
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: zookeeper
    app.kubernetes.io/version: 3.9.2
    helm.sh/chart: zookeeper-13.4.13
    app.kubernetes.io/component: zookeeper
    role: zookeeper
spec:
  replicas: 1
  revisionHistoryLimit: 10
  podManagementPolicy: Parallel
  selector:
    matchLabels:
      app.kubernetes.io/instance: orbilnot
      app.kubernetes.io/name: zookeeper
      app.kubernetes.io/component: zookeeper
  serviceName: orbilnot-zookeeper-headless
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  template:
    metadata:
      annotations:
      labels:
        app.kubernetes.io/instance: orbilnot
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: zookeeper
        app.kubernetes.io/version: 3.9.2
        helm.sh/chart: zookeeper-13.4.13
        app.kubernetes.io/component: zookeeper
    spec:
      enableServiceLinks: true
      serviceAccountName: orbilnot-zookeeper
      
      automountServiceAccountToken: false
      affinity:
        podAffinity:
          
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/instance: orbilnot
                    app.kubernetes.io/name: zookeeper
                    app.kubernetes.io/component: zookeeper
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:
          
      securityContext:
        fsGroup: 1001
        fsGroupChangePolicy: Always
        supplementalGroups: []
        sysctls: []
      initContainers:
      containers:
        - name: zookeeper
          image: docker.io/bitnami/zookeeper:3.9.2-debian-12-r12
          imagePullPolicy: "IfNotPresent"
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
              - ALL
            privileged: false
            readOnlyRootFilesystem: true
            runAsGroup: 1001
            runAsNonRoot: true
            runAsUser: 1001
            seLinuxOptions: {}
            seccompProfile:
              type: RuntimeDefault
          command:
            - /scripts/setup.sh
          resources:
            limits:
              cpu: 375m
              ephemeral-storage: 2Gi
              memory: 384Mi
            requests:
              cpu: 250m
              ephemeral-storage: 50Mi
              memory: 256Mi
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: ZOO_DATA_LOG_DIR
              value: ""
            - name: ZOO_PORT_NUMBER
              value: "2181"
            - name: ZOO_TICK_TIME
              value: "2000"
            - name: ZOO_INIT_LIMIT
              value: "10"
            - name: ZOO_SYNC_LIMIT
              value: "5"
            - name: ZOO_PRE_ALLOC_SIZE
              value: "65536"
            - name: ZOO_SNAPCOUNT
              value: "100000"
            - name: ZOO_MAX_CLIENT_CNXNS
              value: "60"
            - name: ZOO_4LW_COMMANDS_WHITELIST
              value: "srvr, mntr, ruok"
            - name: ZOO_LISTEN_ALLIPS_ENABLED
              value: "no"
            - name: ZOO_AUTOPURGE_INTERVAL
              value: "1"
            - name: ZOO_AUTOPURGE_RETAIN_COUNT
              value: "10"
            - name: ZOO_MAX_SESSION_TIMEOUT
              value: "40000"
            - name: ZOO_SERVERS
              value: orbilnot-zookeeper-0.orbilnot-zookeeper-headless.default.svc.cluster.local:2888:3888::1 
            - name: ZOO_ENABLE_AUTH
              value: "no"
            - name: ZOO_ENABLE_QUORUM_AUTH
              value: "no"
            - name: ZOO_HEAP_SIZE
              value: "1024"
            - name: ZOO_LOG_LEVEL
              value: "ERROR"
            - name: ALLOW_ANONYMOUS_LOGIN
              value: "yes"
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  apiVersion: v1
                  fieldPath: metadata.name
            - name: ZOO_ADMIN_SERVER_PORT_NUMBER
              value: "8080"
          ports:
            - name: client
              containerPort: 2181
            - name: http-admin
              containerPort: 8080
          livenessProbe:
            failureThreshold: 6
            initialDelaySeconds: 30
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - /bin/bash
                - -ec
                - ZOO_HC_TIMEOUT=3 /opt/bitnami/scripts/zookeeper/healthcheck.sh
          readinessProbe:
            failureThreshold: 6
            initialDelaySeconds: 5
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - /bin/bash
                - -ec
                - ZOO_HC_TIMEOUT=2 /opt/bitnami/scripts/zookeeper/healthcheck.sh
          volumeMounts:
            - name: empty-dir
              mountPath: /tmp
              subPath: tmp-dir
            - name: empty-dir
              mountPath: /opt/bitnami/zookeeper/conf
              subPath: app-conf-dir
            - name: empty-dir
              mountPath: /opt/bitnami/zookeeper/logs
              subPath: app-logs-dir
            - name: scripts
              mountPath: /scripts/setup.sh
              subPath: setup.sh
            - name: data
              mountPath: /bitnami/zookeeper
      volumes:
        - name: empty-dir
          emptyDir: {}
        - name: scripts
          configMap:
            name: orbilnot-zookeeper-scripts
            defaultMode: 493
  volumeClaimTemplates:
    - apiVersion: v1
      kind: PersistentVolumeClaim
      metadata:
        name: data
      spec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: "8Gi"
---
# Source: orbilnot/charts/kafka/templates/controller-eligible/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: orbilnot-kafka-controller
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 3.8.0
    helm.sh/chart: kafka-30.1.6
    app.kubernetes.io/component: controller-eligible
    app.kubernetes.io/part-of: kafka
spec:
  podManagementPolicy: Parallel
  replicas: 3
  selector:
    matchLabels:
      app.kubernetes.io/instance: orbilnot
      app.kubernetes.io/name: kafka
      app.kubernetes.io/component: controller-eligible
      app.kubernetes.io/part-of: kafka
  serviceName: orbilnot-kafka-controller-headless
  updateStrategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app.kubernetes.io/instance: orbilnot
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: kafka
        app.kubernetes.io/version: 3.8.0
        helm.sh/chart: kafka-30.1.6
        app.kubernetes.io/component: controller-eligible
        app.kubernetes.io/part-of: kafka
      annotations:
        checksum/configuration: f9dd2e3053da99bcd007922013cf352d363f7f5393e0e89c1aec8fcd5b008e1d
        checksum/passwords-secret: 94ecd5b705b5e68e64118225f9670f419d4f39a7fc10fceb5bafc707e736e4f8
    spec:
      
      automountServiceAccountToken: false
      hostNetwork: false
      hostIPC: false
      affinity:
        podAffinity:
          
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/instance: orbilnot
                    app.kubernetes.io/name: kafka
                    app.kubernetes.io/component: controller-eligible
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:
          
      securityContext:
        fsGroup: 1001
        fsGroupChangePolicy: Always
        seccompProfile:
          type: RuntimeDefault
        supplementalGroups: []
        sysctls: []
      serviceAccountName: orbilnot-kafka
      enableServiceLinks: true
      initContainers:
        - name: kafka-init
          image: docker.io/bitnami/kafka:3.8.0-debian-12-r5
          imagePullPolicy: IfNotPresent
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
              - ALL
            readOnlyRootFilesystem: true
            runAsGroup: 1001
            runAsNonRoot: true
            runAsUser: 1001
            seLinuxOptions: {}
          resources:
            limits: {}
            requests: {} 
          command:
            - /bin/bash
          args:
            - -ec
            - |
              /scripts/kafka-init.sh
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: MY_POD_NAME
              valueFrom:
                fieldRef:
                    fieldPath: metadata.name
            - name: KAFKA_VOLUME_DIR
              value: "/bitnami/kafka"
            - name: KAFKA_MIN_ID
              value: "0"
            - name: KAFKA_CLIENT_USERS
              value: "user1"
            - name: KAFKA_CLIENT_PASSWORDS
              valueFrom:
                secretKeyRef:
                  name: orbilnot-kafka-user-passwords
                  key: client-passwords
            - name: KAFKA_INTER_BROKER_USER
              value: "inter_broker_user"
            - name: KAFKA_INTER_BROKER_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: orbilnot-kafka-user-passwords
                  key: inter-broker-password
            - name: KAFKA_CONTROLLER_USER
              value: "controller_user"
            - name: KAFKA_CONTROLLER_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: orbilnot-kafka-user-passwords
                  key: controller-password
          volumeMounts:
            - name: data
              mountPath: /bitnami/kafka
            - name: kafka-config
              mountPath: /config
            - name: kafka-configmaps
              mountPath: /configmaps
            - name: kafka-secret-config
              mountPath: /secret-config
            - name: scripts
              mountPath: /scripts
            - name: tmp
              mountPath: /tmp
      containers:
        - name: kafka
          image: docker.io/bitnami/kafka:3.8.0-debian-12-r5
          imagePullPolicy: "IfNotPresent"
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
              - ALL
            readOnlyRootFilesystem: true
            runAsGroup: 1001
            runAsNonRoot: true
            runAsUser: 1001
            seLinuxOptions: {}
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: KAFKA_HEAP_OPTS
              value: "-Xmx1024m -Xms1024m"
            - name: KAFKA_KRAFT_CLUSTER_ID
              valueFrom:
                secretKeyRef:
                  name: orbilnot-kafka-kraft-cluster-id
                  key: kraft-cluster-id
            - name: KAFKA_KRAFT_BOOTSTRAP_SCRAM_USERS
              value: "true"
            - name: KAFKA_CLIENT_USERS
              value: "user1"
            - name: KAFKA_CLIENT_PASSWORDS
              valueFrom:
                secretKeyRef:
                  name: orbilnot-kafka-user-passwords
                  key: client-passwords
            - name: KAFKA_INTER_BROKER_USER
              value: "inter_broker_user"
            - name: KAFKA_INTER_BROKER_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: orbilnot-kafka-user-passwords
                  key: inter-broker-password
            - name: KAFKA_CONTROLLER_USER
              value: "controller_user"
            - name: KAFKA_CONTROLLER_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: orbilnot-kafka-user-passwords
                  key: controller-password
          ports:
            - name: controller
              containerPort: 9093
            - name: client
              containerPort: 9092
            - name: interbroker
              containerPort: 9094
          livenessProbe:
            failureThreshold: 3
            initialDelaySeconds: 10
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - pgrep
                - -f
                - kafka
          readinessProbe:
            failureThreshold: 6
            initialDelaySeconds: 5
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            tcpSocket:
              port: "controller"
          resources:
            limits:
              cpu: 750m
              ephemeral-storage: 2Gi
              memory: 768Mi
            requests:
              cpu: 500m
              ephemeral-storage: 50Mi
              memory: 512Mi
          volumeMounts:
            - name: data
              mountPath: /bitnami/kafka
            - name: logs
              mountPath: /opt/bitnami/kafka/logs
            - name: kafka-config
              mountPath: /opt/bitnami/kafka/config/server.properties
              subPath: server.properties
            - name: tmp
              mountPath: /tmp
      volumes:
        - name: kafka-configmaps
          configMap:
            name: orbilnot-kafka-controller-configuration
        - name: kafka-secret-config
          emptyDir: {}
        - name: kafka-config
          emptyDir: {}
        - name: tmp
          emptyDir: {}
        - name: scripts
          configMap:
            name: orbilnot-kafka-scripts
            defaultMode: 493
        - name: logs
          emptyDir: {}
  volumeClaimTemplates:
    - apiVersion: v1
      kind: PersistentVolumeClaim
      metadata:
        name: data
      spec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: "8Gi"
---
# Source: orbilnot/charts/postgresql/templates/primary/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: orbilnot-postgresql
  namespace: "default"
  labels:
    app.kubernetes.io/instance: orbilnot
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 16.4.0
    helm.sh/chart: postgresql-15.5.24
    app.kubernetes.io/component: primary
spec:
  replicas: 1
  serviceName: orbilnot-postgresql-hl
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/instance: orbilnot
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/component: primary
  template:
    metadata:
      name: orbilnot-postgresql
      labels:
        app.kubernetes.io/instance: orbilnot
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: postgresql
        app.kubernetes.io/version: 16.4.0
        helm.sh/chart: postgresql-15.5.24
        app.kubernetes.io/component: primary
    spec:
      serviceAccountName: orbilnot-postgresql
      
      automountServiceAccountToken: false
      affinity:
        podAffinity:
          
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/instance: orbilnot
                    app.kubernetes.io/name: postgresql
                    app.kubernetes.io/component: primary
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:
          
      securityContext:
        fsGroup: 1001
        fsGroupChangePolicy: Always
        supplementalGroups: []
        sysctls: []
      hostNetwork: false
      hostIPC: false
      containers:
        - name: postgresql
          image: docker.io/bitnami/postgresql:16.4.0-debian-12-r2
          imagePullPolicy: "IfNotPresent"
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
              - ALL
            privileged: false
            readOnlyRootFilesystem: true
            runAsGroup: 1001
            runAsNonRoot: true
            runAsUser: 1001
            seLinuxOptions: {}
            seccompProfile:
              type: RuntimeDefault
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: POSTGRESQL_PORT_NUMBER
              value: "5432"
            - name: POSTGRESQL_VOLUME_DIR
              value: "/bitnami/postgresql"
            - name: PGDATA
              value: "/bitnami/postgresql/data"
            # Authentication
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: orbilnot-postgresql
                  key: postgres-password
            - name: POSTGRES_DATABASE
              value: "postgres"
            # LDAP
            - name: POSTGRESQL_ENABLE_LDAP
              value: "no"
            # TLS
            - name: POSTGRESQL_ENABLE_TLS
              value: "no"
            # Audit
            - name: POSTGRESQL_LOG_HOSTNAME
              value: "false"
            - name: POSTGRESQL_LOG_CONNECTIONS
              value: "false"
            - name: POSTGRESQL_LOG_DISCONNECTIONS
              value: "false"
            - name: POSTGRESQL_PGAUDIT_LOG_CATALOG
              value: "off"
            # Others
            - name: POSTGRESQL_CLIENT_MIN_MESSAGES
              value: "error"
            - name: POSTGRESQL_SHARED_PRELOAD_LIBRARIES
              value: "pgaudit"
          ports:
            - name: tcp-postgresql
              containerPort: 5432
          livenessProbe:
            failureThreshold: 6
            initialDelaySeconds: 30
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - /bin/sh
                - -c
                - exec pg_isready -U "postgres" -d "dbname=postgres" -h 127.0.0.1 -p 5432
          readinessProbe:
            failureThreshold: 6
            initialDelaySeconds: 5
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - /bin/sh
                - -c
                - -e
                - |
                  exec pg_isready -U "postgres" -d "dbname=postgres" -h 127.0.0.1 -p 5432
                  [ -f /opt/bitnami/postgresql/tmp/.initialized ] || [ -f /bitnami/postgresql/.initialized ]
          resources:
            limits:
              cpu: 150m
              ephemeral-storage: 2Gi
              memory: 192Mi
            requests:
              cpu: 100m
              ephemeral-storage: 50Mi
              memory: 128Mi
          volumeMounts:
            - name: empty-dir
              mountPath: /tmp
              subPath: tmp-dir
            - name: empty-dir
              mountPath: /opt/bitnami/postgresql/conf
              subPath: app-conf-dir
            - name: empty-dir
              mountPath: /opt/bitnami/postgresql/tmp
              subPath: app-tmp-dir
            - name: dshm
              mountPath: /dev/shm
            - name: data
              mountPath: /bitnami/postgresql
      volumes:
        - name: empty-dir
          emptyDir: {}
        - name: dshm
          emptyDir:
            medium: Memory
  volumeClaimTemplates:
    - apiVersion: v1
      kind: PersistentVolumeClaim
      metadata:
        name: data
      spec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: "8Gi"

NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace default -l "app.kubernetes.io/name=orbilnot,app.kubernetes.io/instance=orbilnot" -o jsonpath="{.items[0].metadata.name}")
  export CONTAINER_PORT=$(kubectl get pod --namespace default $POD_NAME -o jsonpath="{.spec.containers[0].ports[0].containerPort}")
  echo "Visit http://127.0.0.1:8080 to use your application"
  kubectl --namespace default port-forward $POD_NAME 8080:$CONTAINER_PORT
